<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Hillingar | gibbr.org</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="/style.css" />
  <link rel="shortcut icon" href="/favicon.ico">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<ul class="navbar" id="navbar">
<li>
<a href="/">home</a>
</li>
<li>
<a href="/blog/">blog</a>
</li>
<li>
<a href="/links.html">links</a>
</li>
</ul>
<h1 id="hillingar-building-mirage-unikernels-with-nix"><a
href="#hillingar-building-mirage-unikernels-with-nix" class="anchor"
aria-hidden="true">Hillingar: building Mirage unikernels with
Nix</a></h1>
<p>2022-10-17</p>
<blockquote>
<p>An arctic mirage<span class="citation"
data-cites="lehnNovayaZemlyaEffect1979"><a
href="#ref-lehnNovayaZemlyaEffect1979"
role="doc-biblioref">[1]</a></span></p>
</blockquote>
<figure>
<img src="./hillingar2-caml.png" data-min-width="5cm"
style="width:70.0%" alt="" />
<figcaption aria-hidden="true"><a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></figcaption>
</figure>
<h2 id="introduction"><a href="#introduction" class="anchor"
aria-hidden="true">Introduction</a></h2>
<p>As part of my master’s thesis, I’ve been hosting an authoritative DNS
server at <code>ns1.gibbr.org</code>. More can be read in the
dissertation <span class="citation"
data-cites="gibbSpatialNameSystem2022"><a
href="#ref-gibbSpatialNameSystem2022"
role="doc-biblioref">[2]</a></span>, but DNS is one of the fundamental
building blocks of the modern Internet. And as part of my master’s
thesis procrastination, I’ve been running it on a NixOS machine. Using
NixOS, deploying a DNS server is as simple as:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">zones</span>.<span class="st">&quot;gibbr.org&quot;</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="va">master</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="va">file</span> <span class="op">=</span> <span class="st">&quot;gibbr.org.zone&quot;</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Which we can then query with</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> dig gibbr.org @ns1.gibbr.org +short</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">45.77.205.198</span></span></code></pre></div>
<p>Setting up a glue record with our registrar pointing
<code>ns1.gibbr.org</code> to the IP address of our DNS-hosting machine
allows anyone to use our authoritative server via their resolver.</p>
<p>As you might notice, this is running the venerable bind<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
written in C. As an alternative, using functional high-level type-safe
programming languages to create network applications can greatly benefit
safety and usability whilst maintaining performant execution <span
class="citation"
data-cites="madhavapeddyMelangeCreatingFunctional2007"><a
href="#ref-madhavapeddyMelangeCreatingFunctional2007"
role="doc-biblioref">[3]</a></span>. One such language is OCaml.</p>
<p>The MirageOS project is a deployment method for these OCaml programs
<span class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[4]</a></span>. Instead of running them as a
traditional Unix process, we instead create a specialised ‘unikernel’
operating system to run the application, which allows dead code
elimination improving security with smaller attack surfaces and improved
efficiency.</p>
<p>However, to deploy a Mirage unikernel with NixOS one has to use the
imperative deployment methodologies native to the OCaml ecosystem,
eliminating the benefit of reproducible systems that Nix gives us. This
blog post will explore how we enabled reproducible deployments of Mirage
unikernels with Nix.</p>
<h2 id="nix"><a href="#nix" class="anchor"
aria-hidden="true">Nix</a></h2>
<figure>
<img src="./nix-snowflake.svg" data-min-width="5cm" style="width:60.0%"
alt="Nix snowflake" />
<figcaption aria-hidden="true">Nix snowflake<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></figcaption>
</figure>
<p>At this point, the curious reader might be wondering, what on earth
is ‘Nix’?</p>
<p>Nix is a deployment system that uses cryptographic hashes to compute
unique paths for components<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a> which are stored in a
read-only directory, the Nix store, at
<code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code>.
<!-- We replace references to a component with this absolute path, or symlink into the nix store for the system path, for example. -->
This provides a number of benefits including concurrent installation of
multiple versions of a package, atomic upgrades and downgrades, and
multiple user environments <span class="citation"
data-cites="dolstraNixSafePolicyFree2004"><a
href="#ref-dolstraNixSafePolicyFree2004"
role="doc-biblioref">[5]</a></span>.</p>
<p>Nix uses a declarative domain-specific language (DSL), also called
‘Nix’, to build and configure software. The snippet used to deploy the
DNS server is in fact a Nix expression. This example doesn’t demonstrate
it but Nix is Turing complete, being inspired by Haskell. Nix does not,
however, have a type system.</p>
<p>We used the DSL to write derivations for software, which describes
how to build said software with input components and a build script.
This Nix expression is then ‘instantiated’ to create ‘store derivations’
(<code>.drv</code> files), which is the low-level representation of how
to build a single component. This store derivation is ‘realised’ into a
built artefact, hereafter referred to as ‘building’.</p>
<p>Possibly the simplest Nix derivation uses bash to create a single
file containing <code>Hello, World!</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span>  <span class="op">}</span> <span class="op">}</span>:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">system</span> <span class="op">=</span> <span class="bu">builtins</span>.currentSystem<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>nixpkgs.bash<span class="sc">}</span><span class="st">/bin/bash&quot;</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&#39;&#39;echo &quot;Hello, World!&quot; &gt; $out&#39;&#39;</span> <span class="op">];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that <code>derivation</code> is a function that we’re calling
with one argument which is a set of attributes.</p>
<p>We can instantiate this Nix derivation expression to create a store
derivation:</p>
<pre><code>$ nix-instantiate default.nix
/nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv
$ nix show-derivation /nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv
{
  &quot;/nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello&quot;
      }
    },
    &quot;inputSrcs&quot;: [],
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/mnyhjzyk43raa3f44pn77aif738prd2m-bash-5.1-p16.drv&quot;: [
        &quot;out&quot;
      ]
    },
    &quot;system&quot;: &quot;x86_64-linux&quot;,
    &quot;builder&quot;: &quot;/nix/store/2r9n7fz1rxq088j6mi5s7izxdria6d5f-bash-5.1-p16/bin/bash&quot;,
    &quot;args&quot;: [ &quot;-c&quot;, &quot;echo \&quot;Hello, World!\&quot; &gt; $out&quot; ],
    &quot;env&quot;: {
      &quot;builder&quot;: &quot;/nix/store/2r9n7fz1rxq088j6mi5s7izxdria6d5f-bash-5.1-p16/bin/bash&quot;,
      &quot;name&quot;: &quot;hello&quot;,
      &quot;out&quot;: &quot;/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello&quot;,
      &quot;system&quot;: &quot;x86_64-linux&quot;
    }
  }
}</code></pre>
<p>And build the store derivation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix-store <span class="at">--realise</span> /nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Hello,</span> World!</span></code></pre></div>
<p>Most nix tooling does these two steps together:</p>
<pre><code>nix-build default.nix
this derivation will be built:
  /nix/store/q5hg3vqby8a9c8pchhjal3la9n7g1m0z-hello.drv
building &#39;/nix/store/q5hg3vqby8a9c8pchhjal3la9n7g1m0z-hello.drv&#39;...
/nix/store/zyrki2hd49am36jwcyjh3xvxvn5j5wml-hello</code></pre>
<p>Nix realisations (hereafter referred to as builds) are done in
isolation to ensure reproducibility. Projects often rely on interacting
with package managers to make sure all dependencies are available, and
may implicitly rely on system configuration at build time. To prevent
this, every Nix derivation is built in isolation, without network access
or access to the global file system, with only other Nix derivations as
inputs.</p>
<blockquote>
<p>The name Nix is derived from the Dutch word niks, meaning nothing;
build actions do not see anything that has not been explicitly declared
as an input <span class="citation"
data-cites="dolstraNixSafePolicyFree2004"><a
href="#ref-dolstraNixSafePolicyFree2004"
role="doc-biblioref">[5]</a></span>.</p>
</blockquote>
<!-- There are analogies to functional program versus imperative programming, but applied to system management and software builds/deployment. -->
<h4 id="nixpkgs"><a href="#nixpkgs" class="anchor"
aria-hidden="true">Nixpkgs</a></h4>
<p>You may have noticed a reference to <code>nixpkgs</code> in the above
derivation. As every input to a Nix derivation also has to be a Nix
derivation, one can imagine the tedium involved in creating a Nix
derivation for every dependency of your project. However, Nixpkgs<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> is a large repository of software
packaged in Nix, where a package is a Nix derivation. We can use
packages from Nixpkgs as inputs to a Nix derivation, as we’ve done with
<code>bash</code>.</p>
<p>There is also a command line package manager installing packages from
Nixpkgs, which is why people often refer to Nix as a package manager.
While Nix, and Therefore nix package management, is primarily
source-based – since derivations describe how to build software from
source – binary deployment is an optimization of this. Since packages
are built in isolation and entirely determined by their inputs, binaries
can be transparently deployed by downloading them from a remote server
instead of building the derivation locally.</p>
<figure>
<img src="./nixpkgs.png" data-min-width="5cm" style="width:100.0%"
alt="Visualisation of Nixpkgs" />
<figcaption aria-hidden="true">Visualisation of Nixpkgs<a href="#fn6"
class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></figcaption>
</figure>
<h4 id="nixos"><a href="#nixos" class="anchor"
aria-hidden="true">NixOS</a></h4>
<p>NixOS<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> is a Linux distribution built with
Nix from a modular, purely functional specification <span
class="citation" data-cites="dolstraNixOSPurelyFunctional2008"><a
href="#ref-dolstraNixOSPurelyFunctional2008"
role="doc-biblioref">[6]</a></span>. It has no traditional filesystem
hierarchy (FSH) – like <code>/bin</code>, <code>/lib</code>,
<code>/usr</code> – but instead stores all components in
<code>/nix/store</code>. The configuration of the system is managed by
Nix, with configuration files being built from modular Nix expressions.
NixOS modules are just that – small bits of configuration written in Nix
that can be composed to build a full NixOS system<a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.
While many NixOS modules are provided in the Nixpkgs repository they can
also be written by an individual user. For example, the expression used
to deploy a DNS server is a NixOS module. Together these modules form
the configuration which builds the Linux system as a Nix derivation.</p>
<p>NixOS minimises global mutable state that – without knowing it – you
might rely on being set up in a certain way. For example, you might
follow instructions to run a series of shell commands, and edit some
files in a certain way, to get a piece of software working. You may
subsequently be unable to reproduce the result because you’ve forgotten
some intricacy, or are now using a different version of the software.
Nix forces you to encode this in a reproducible way, which is extremely
useful for replicating software configurations and deployments, aiming
to solve the ‘It works on my machine’ problem. Docker is often used to
fix this configuration problem, but nix aims to be more reproducible.
This can be frustrating at times because it can make it harder to get
off the ground with a project, but I’ve found the benefits outweigh the
downsides personally.</p>
<p>My own NixOS configuration is publicly available<a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.
This makes it trivial to reproduce my system – a collection of various
configurations, services, and hacks – on another machine. I use it to
manage servers, workstations, and more. Compared to my previous approach
of maintaining a git repository of dotfiles, this is much more modular,
reproducible, and flexible. And if you want to deploy some new piece of
software or service, it can be as easy as changing a single line in your
system configuration.</p>
<p>Despite these advantages, the reason I switched to NixOS from Arch
Linux was simpler; NixOS allows rollbacks and atomic upgrades. As Arch
packages bleeding-edge software with rolling updates it would frequently
happen that some new version of something I was using would break. Arch
has one global coherent package set, so to avoid complications with
solving dependency versions Arch doesn’t support partial upgrades. Given
this, the options were to wait for the bug to be fixed, or manually
rollback all the updated packages by inspecting the pacman log (the Arch
package manager) and reinstalling the old versions from the local cache.
While there may be tools on top of pacman to improve this, the straw
that broke the camel’s back was when my machine crashed while updating
the Linux kernel and I had to reinstall it from a live USB.</p>
<p>While Nixpkgs also has one global coherent package set, one can use
multiple instances of Nixpkgs (i.e. channels) at once to support partial
upgrades, as the Nix store allows multiple versions of a dependency to
be stored. This also supports atomic upgrades as all the old versions of
software can be kept until garbage collected. The pointers to the new
packages are only updated when the install succeeds, so the crash during
the Linux kernel upgrade would not have broken my OS install on NixOS.
And every new system configuration creates a GRUB entry, so you can boot
previous systems even from your UEFI/BIOS.</p>
<p>To summarise the parts of the Nix ecosystem that we’ve discussed:</p>
<p><img src="./nix-stack.svg" data-min-width="5cm"
style="width:50.0%" /></p>
<h4 id="flakes"><a href="#flakes" class="anchor"
aria-hidden="true">Flakes</a></h4>
<p>We also use Nix flakes for this project. Without going into too much
depth, for our purposes, they enable hermetic evaluation of nix
expressions and provide a standard way to compose Nix projects. With
flakes, instead of using a Nixpkgs repository version from a ‘channel’<a
href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>, we pin Nixpkgs as an input to
every Nix flake – be it a project build with Nix or a NixOS system.
<!-- One of the reasons for improving Nix project composing is that there's some discussion around the sustainability of the Nixpkgs monorepo workflow^[https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741](https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741]. -->
Integrated with flakes there is also a new <code>nix</code> command
aimed at improving the UI of Nix. More detail about flakes can be read
in a series of blog posts by Eelco on the topic<a href="#fn11"
class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a>.</p>
<h2 id="mirageos"><a href="#mirageos" class="anchor"
aria-hidden="true">MirageOS</a></h2>
<figure>
<img src="./mirage-logo.svg" data-min-width="5cm" style="width:50.0%"
alt="" />
<figcaption aria-hidden="true"><a href="#fn12" class="footnote-ref"
id="fnref12" role="doc-noteref"><sup>12</sup></a></figcaption>
</figure>
<p>MirageOS is a library operating system that creates unikernels
containing low-level operating system code and high-level application
code bundled into one kernel and one address space <span
class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[4]</a></span>.
<!-- security, performance, speed --> It was the first such ‘unikernel
creation framework’, but it comes from a long lineage of OS research
such as the exokernel library OS architecture <span class="citation"
data-cites="englerExokernelOperatingSystem"><a
href="#ref-englerExokernelOperatingSystem"
role="doc-biblioref">[7]</a></span>. Embedding application code in the
kernel allows for dead-code elimination – removing OS interfaces that
are used – reducing the unikernels attack surface and offering improved
efficiency.</p>
<figure>
<img src="./mirage-diagram.svg" data-min-width="5cm" style="width:70.0%"
alt="Contrasting software layers in existing VM appliances vs. unikernel’s standalone kernel compilation approach [4]" />
<figcaption aria-hidden="true">Contrasting software layers in existing
VM appliances vs. unikernel’s standalone kernel compilation approach
<span class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[4]</a></span></figcaption>
</figure>
<p>Mirage unikernels are written in the typesafe high-level functional
programming language OCaml. OCaml is a bit more practical than other
functional programming languages such as Haskell for systems
programming, such as supporting falling back on impure imperative code
or mutable variables when warranted.</p>
<h2 id="deploying-unikernels"><a href="#deploying-unikernels"
class="anchor" aria-hidden="true">Deploying Unikernels</a></h2>
<p>Now that we understand what Nix and Mirage are, and we’ve motivated
the desire to deploy Mirage unikernels on a NixOS machine, what’s
stopping us from doing just that? Well, to support deploying a Mirage
unikernel, such as for a DNS server, we would need to write a NixOS
module for it.</p>
<p>A paired-down<a href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a> version of the bind NixOS module,
the module we use in our Nix expression for deploying a DNS server on
NixOS (<a href="#cb1">§</a>), is:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">config</span><span class="op">,</span> <span class="va">lib</span><span class="op">,</span> <span class="va">pkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> lib<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">options</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> mkEnableOption <span class="st">&quot;BIND domain name server&quot;</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">zones</span> <span class="op">=</span> mkOption <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="va">config</span> <span class="op">=</span> mkIf cfg.enable <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">systemd</span>.<span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>      <span class="va">description</span> <span class="op">=</span> <span class="st">&quot;BIND Domain Name Server&quot;</span><span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>      <span class="va">after</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;network.target&quot;</span> <span class="op">];</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>      <span class="va">wantedBy</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;multi-user.target&quot;</span> <span class="op">];</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      <span class="va">serviceConfig</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">ExecStart</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.bind.out<span class="sc">}</span><span class="st">/sbin/named&quot;</span><span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice the reference to <code>pkgs.bind</code>. This is the Nixpkgs
repository Nix derivation for the <code>bind</code> package. Recall that
every input to a Nix derivation is itself a Nix derivation (<a
href="#nixpkgs">§</a>); in order to use a package in a Nix expression –
i.e. a NixOS module – we need to build said package with Nix. Once we
build a Mirage unikernel with Nix, we can write a NixOS module to deploy
it.</p>
<h2 id="building-unikernels"><a href="#building-unikernels"
class="anchor" aria-hidden="true">Building Unikernels</a></h2>
<p>Mirage uses the package manager for OCaml called Opam<a href="#fn14"
class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.
dependencies in Opam, as is common in programming language package
managers, has a file which – among other meta-data, build/install
scripts – specifies dependencies and their version constraints. For
example<a href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a></p>
<pre><code>...
depends: [
  &quot;arp&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;ethernet&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;lwt&quot; { ?monorepo }
  &quot;mirage&quot; { build &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;4.3.0&quot; }
  &quot;mirage-bootvar-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.6.0&quot; &amp; &lt; &quot;0.7.0&quot; }
  &quot;mirage-clock-solo5&quot; { ?monorepo &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;5.0.0&quot; }
  &quot;mirage-crypto-rng-mirage&quot; { ?monorepo &amp; &gt;= &quot;0.8.0&quot; &amp; &lt; &quot;0.11.0&quot; }
  &quot;mirage-logs&quot; { ?monorepo &amp; &gt;= &quot;1.2.0&quot; &amp; &lt; &quot;2.0.0&quot; }
  &quot;mirage-net-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.8.0&quot; &amp; &lt; &quot;0.9.0&quot; }
  &quot;mirage-random&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;mirage-runtime&quot; { ?monorepo &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;4.3.0&quot; }
  &quot;mirage-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.9.0&quot; &amp; &lt; &quot;0.10.0&quot; }
  &quot;mirage-time&quot; { ?monorepo }
  &quot;mirageio&quot; { ?monorepo }
  &quot;ocaml&quot; { build &amp; &gt;= &quot;4.08.0&quot; }
  &quot;ocaml-solo5&quot; { build &amp; &gt;= &quot;0.8.1&quot; &amp; &lt; &quot;0.9.0&quot; }
  &quot;opam-monorepo&quot; { build &amp; &gt;= &quot;0.3.2&quot; }
  &quot;tcpip&quot; { ?monorepo &amp; &gt;= &quot;7.0.0&quot; &amp; &lt; &quot;8.0.0&quot; }
  &quot;yaml&quot; { ?monorepo &amp; build }
]
...</code></pre>
<p>And each of these dependencies will have its own dependencies with
their own version constraints. As we can only link one dependency into
the resulting program, we need to solve a set of dependency versions
that satisfies these constraints. This is not an easy problem. In fact,
it’s NP-complete <span class="citation"
data-cites="coxVersionSAT2016"><a href="#ref-coxVersionSAT2016"
role="doc-biblioref">[8]</a></span>. Opam uses the Zero Install<a
href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a> SAT solver for dependency
resolution.</p>
<p>Nixpkgs has a large number of OCaml packages<a href="#fn17"
class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>
which we could provide as build inputs to a Nix derivation. But they are
not as complete nor up to date as those in
<code>opam-repository</code><a href="#fn18" class="footnote-ref"
id="fnref18" role="doc-noteref"><sup>18</sup></a>. A larger issue,
however, is that Nixpkgs has one global coherent set of package
versions<a href="#fn19" class="footnote-ref" id="fnref19"
role="doc-noteref"><sup>19</sup></a> <a href="#fn20"
class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>.
The support for installing multiple versions of a package concurrently
comes from the fact that they are stored at a unique path and can be
referenced separately, or symlinked, where required. So different
projects or users that use a different version of Nixpkgs won’t
conflict, but Nix does not do any dependency version resolution –
everything is pinned. This has led to much confusion<a href="#fn21"
class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>
with how to install a specific version of a package.</p>
<p>Luckily there already exists a project from Tweag called
<code>opam-nix</code> to deal with this<a href="#fn22"
class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>
<a href="#fn23" class="footnote-ref" id="fnref23"
role="doc-noteref"><sup>23</sup></a>. This project uses the Opam
dependency versions solver inside a Nix derivation, and then something
called Import From Derivation (IFD)<a href="#fn24" class="footnote-ref"
id="fnref24" role="doc-noteref"><sup>24</sup></a> to create derivations
from the resulting dependency versions. Materialization can be used to
create a kind of lockfile for this resolution which can be committed to
the project to avoid having to do IFD on every new build. An alternative
may be to use Opam’s in-built version pinning<a href="#fn25"
class="footnote-ref" id="fnref25"
role="doc-noteref"><sup>25</sup></a>.</p>
<p>This still doesn’t support building our Mirage unikernels, though.
Unikernels quite often need to be cross-compiled: compiled to run on a
platform other than the one they’re being built on. A common target,
Solo5<a href="#fn26" class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a>, is a sandboxed execution
environment – essentially acting as a minimal shim layer to interface
between unikernels and different hypervisor backends. Solo5 uses a
different <code>glibc</code> which requires cross-compilation. Mirage
4<a href="#fn27" class="footnote-ref" id="fnref27"
role="doc-noteref"><sup>27</sup></a> uses the Dune build system<a
href="#fn28" class="footnote-ref" id="fnref28"
role="doc-noteref"><sup>28</sup></a> which supports cross-compilation
through toolchains; a host compiler is installed in an Opam switch (a
virtual environment) as normal, and a target compiler<a href="#fn29"
class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>
is created by modifying the host compiler. But the cross-compilation
context of packages is only known at build time, as some metaprogramming
modules may require preprocessing with the host compiler. To ensure that
the right compilation context is used, this means we have to provide
Dune the sources of all our dependencies. A tool called
<code>opam-monorepo</code> was created to do just that<a href="#fn30"
class="footnote-ref" id="fnref30"
role="doc-noteref"><sup>30</sup></a>.</p>
<p>We extended the <code>opam-nix</code> project to support the
<code>opam-monorepo</code> workflow with this pull request: <a
href="https://github.com/tweag/opam-nix/pull/18">github.com/tweag/opam-nix/pull/18</a>.</p>
<p>This is very low-level support for building Mirage unikernels with
Nix, however. In order to provide a better user experience, we also
created the Hillinar Nix flake: <a
href="https://github.com/ryanGibb/hillingar">github.com/RyanGibb/hillingar</a>.
This wraps the mirage tooling and <code>opam-nix</code> function calls
so that a simple high-level flake can be dropped into a Mirage project
to support building it with Nix. To add Nix build support to a
unikernel, simply:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a flake from hillingar&#39;s default template</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix flake new . <span class="at">-t</span> github:/RyanGibb/hillingar</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># substitute the name of the unikernel you&#39;re building</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sed <span class="at">-i</span> <span class="st">&#39;s/throw &quot;Put the unikernel name here&quot;/&quot;&lt;unikernel-name&gt;&quot;/g&#39;</span> flake.nix</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># build the unikernel with Nix for a particular target</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix build .#<span class="op">&lt;</span>target<span class="op">&gt;</span></span></code></pre></div>
<p>For example, see the flake for building the Mirage website as a
unikernel with Nix: <a
href="https://github.com/RyanGibb/mirage-www/blob/master/flake.nix">github.com/RyanGibb/mirage-www/blob/master/flake.nix</a>.</p>
<h2 id="dependency-management"><a href="#dependency-management"
class="anchor" aria-hidden="true">Dependency Management</a></h2>
<p>To step back for a moment and look at the big picture, we can
consider a number of different types of dependencies at play here:</p>
<ol type="1">
<li>System dependencies:<br> Are dependencies installed through the
system package manager – <code>depexts</code> in Opam parlance. This is
Nix for Hillinar, but another platform’s package managers include
<code>apt</code>, <code>pacman</code>, and <code>brew</code>. For
unikernels these are often C libraries like <code>gmp</code>.</li>
<li>Library dependencies:<br> Are installed through the programming
language package manager. For example <code>opam</code>,
<code>pip</code>, and <code>npm</code>. These are the dependencies that
often have version constraints and require resolution possibly using a
SAT solver.</li>
<li>File dependencies:<br> Are dependencies at the file system level of
granularity. For example, C files, Java (non-inner) classes, or OCaml
modules. Most likely this will be for a single project, but in a
monorepo these could span many projects which all interoperate
(e.g. Nixpkgs). This is the level of granuality that builds systems
often deal with – like Make, Dune, and Bazel.</li>
<li>Function dependencies:<br> Are dependencies between functions or
another unit of code native to a language. For example, if function
<code>a</code> calls function <code>b</code>, then <code>a</code>
‘depends’ on <code>b</code>. This is the level of granualrity that
compilers and interpretters are normally concerened with.</li>
</ol>
<p>Nix deals well with system dependencies but doesn’t have a native way
of resolving library dependency versions. Opam deals well with library
dependencies but doesn’t have a consistent way of installing system
packages in a reproducible way. And Dune deals with file dependencies,
but not the others. The OCaml compiler keeps track of function
dependencies when compiling and linking a program.</p>
<h4 id="cross-compilation"><a href="#cross-compilation" class="anchor"
aria-hidden="true">Cross-compilation</a></h4>
<p>Dune is used to support cross-compilation for Mirage unikernels (<a
href="#building-unikernels">§</a>). We encode the cross-compilation
context in Dune using the <code>preprocess</code> stanza from Dune’s
DSL, for example from <a
href="https://github.com/mirage/mirage-tcpip/blob/3ab30ab7b43dede75abf7b37838e051e0ddbb23a/src/tcp/dune#L9-L10"><code>mirage-tcpip</code></a>:</p>
<pre><code>(library
 (name tcp)
 (public_name tcpip.tcp)
 (instrumentation
  (backend bisect_ppx))
 (libraries logs ipaddr cstruct lwt-dllist mirage-profile tcpip.checksum
   tcpip duration randomconv fmt mirage-time mirage-clock mirage-random
   mirage-flow metrics)
 (preprocess
  (pps ppx_cstruct)))</code></pre>
<p>Which tells dune to preprocess the Opam package
<code>ppx_cstruct</code> with the host compiler. As this information is
only available from the build manager, this requires fetching all
dependency sources to support cross compilation with the
<code>opam-monorepo</code> tool:</p>
<blockquote>
<p>Cross-compilation - the details of how to build some native code can
come late in the pipeline, which isn’t a problem if the sources are
available<a href="#fn31" class="footnote-ref" id="fnref31"
role="doc-noteref"><sup>31</sup></a>.</p>
</blockquote>
<p>This means we’re essentially encoding the compilation context in the
build system rules. To remove the requirement to clone dependency
sources locally with <code>opam-monorepo</code> we could try and encode
the compilation context in the package manager. However, preprocessing
can be at the OCaml module level of granualrity. Dune deals with this
level of granuality with file dependencies, but Opam doesn’t. Tigher
integration between the build and package manager could improve this
situation, like Rust’s <code>cargo</code>. There are some plans towards
modularising Opam and creating tigher integration with Dune.</p>
<p>There is also the possibility of using Nix to avoid
cross-compilation. Nixpkg’s cross compilation<a href="#fn32"
class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>
will not help us here, as it simply specifies how to package software in
a cross-compilation friendly way. However, Nix remote builders would
enable reproducible builds on a remote machine<a href="#fn33"
class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>
with Nix installed that may sidestep the need for cross-compilation in
certain contexts.</p>
<h4 id="version-resolution"><a href="#version-resolution" class="anchor"
aria-hidden="true">Version Resolution</a></h4>
<p>Hillingar uses the Zero Install SAT solver for version resolution
through Opam. While this works, it isn’t the most principled approach
for getting Nix to work with library dependencies. Some package managers
are just using Nix for system dependencies and using the existing
tooling as normal for library dependencies<a href="#fn34"
class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a>.
But generally, <code>X2nix</code> projects are numerous and created in
an ad hoc way. Part of this is dealing with every language’s ecosystems
package repository system, and there are existing approaches<a
href="#fn35" class="footnote-ref" id="fnref35"
role="doc-noteref"><sup>35</sup></a> <a href="#fn36"
class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>
aimed at reducing code duplication, but there is still the fundamental
problem of version resolution. Nix uses pointers (paths) to refer to
different versions of a dependency, which works well solving the diamond
dependency problem for system depdnencies, but we don’t have this luxury
when linking a binary with library dependencies.</p>
<figure>
<img src="version-sat.svg" data-min-width="5cm" style="width:100.0%"
alt="The diamond dependency problem [8]." />
<figcaption aria-hidden="true">The diamond dependency problem <span
class="citation" data-cites="coxVersionSAT2016"><a
href="#ref-coxVersionSAT2016"
role="doc-biblioref">[8]</a></span>.</figcaption>
</figure>
<p>This is exactly why Opam uses a constraint solver to find a coherent
package set. But what if we could split version solving functionality
into something that can tie into any language ecosystem? This could be a
more principled, elegant, approach to the current fragmented state of
library dependencies (program language package managers). This would
require some ecosystem-specific logic to, for example, obtain the
version constraints and to create derivations for the resulting sources,
but the core functionality could be ecosystem agnostic. As with
<code>opam-nix</code>, materialization<a href="#fn37"
class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a>
could be used to commit a lockfile and avoid IFD. Although perhaps this
is too lofty a goal to be practical, and perhaps the real issues are
organisational rather than technical.</p>
<p>Nix allows multiple versions of a package to be installed
simultaneously by having different derivations refer to different paths
in the Nix store concurrently. What if we could use a similar approach
for linking binaries to sidestep the version constraint solving
altogether at the cost of larger binaries? Nix makes a similar tradeoff
makes with disk space. A very simple approach might be to
programmatically prepend/append functions in <code>D</code> with the
dependency version name <code>vers1</code> and <code>vers2</code> for
calls in the packages <code>B</code> and <code>C</code> respectively in
the diagram above.</p>
<blockquote>
<p>Another way to avoid NP-completeness is to attack assumption 4: what
if two different versions of a package could be installed
simultaneously? Then almost any search algorithm will find a combination
of packages to build the program; it just might not be the smallest
possible combination (that’s still NP-complete). If B needs D 1.5 and C
needs D 2.2, the build can include both packages in the final binary,
treating them as distinct packages. I mentioned above that there can’t
be two definitions of printf built into a C program, but languages with
explicit module systems should have no problem including separate copies
of D (under different fully-qualified names) into a program. <span
class="citation" data-cites="coxVersionSAT2016"><a
href="#ref-coxVersionSAT2016" role="doc-biblioref">[8]</a></span></p>
</blockquote>
<p>Another wackier idea is instead of having programmers manually
specific constraints with version numbers, to resolve dependencies
purely based on typing<a href="#fn38" class="footnote-ref" id="fnref38"
role="doc-noteref"><sup>38</sup></a>. The issue here is that solving
dependencies would now involve type checking, which could prove
computationally expensive.</p>
<h4 id="build-systems"><a href="#build-systems" class="anchor"
aria-hidden="true">Build systems</a></h4>
<p>The build script in a Nix derivation – if it doesn’t invoke a
compiler directly – often invokes a build system like Make, or in this
case Dune. But Nix can also be considered a build system with a
suspending scheduler and deep constructive trace rebuilding <span
class="citation" data-cites="mokhovBuildSystemsCarte2018"><a
href="#ref-mokhovBuildSystemsCarte2018"
role="doc-biblioref">[9]</a></span>. But Nix is at a coarse-grained
package level, invoking these finer-grained build systems to deal with
file dependencies.</p>
<p>In Chapter 10 of the original Nix thesis <span class="citation"
data-cites="dolstraPurelyFunctionalSoftware2006"><a
href="#ref-dolstraPurelyFunctionalSoftware2006"
role="doc-biblioref">[10]</a></span> low-level build management using
Nix is discussed, proposing extending Nix to support file dependencies.
For example, to build the ATerm library:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="va">sharedLib</span> <span class="op">?</span> <span class="cn">true</span><span class="op">}</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> <span class="op">(</span><span class="bu">import</span> <span class="ss">../../../lib</span><span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">rec</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">sources</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./afun.c</span> <span class="ss">./aterm.c</span> <span class="ss">./bafio.c</span> <span class="ss">./byteio.c</span> <span class="ss">./gc.c</span> <span class="ss">./hash.c</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="ss">./list.c</span> <span class="ss">./make.c</span> <span class="ss">./md5c.c</span> <span class="ss">./memory.c</span> <span class="ss">./tafio.c</span> <span class="ss">./version.c</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">compile</span> <span class="op">=</span> <span class="va">main</span><span class="op">:</span> compileC <span class="op">{</span><span class="kw">inherit</span> main sharedLib<span class="op">;};</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="va">libATerm</span> <span class="op">=</span> makeLibrary <span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">libraryName</span> <span class="op">=</span> <span class="st">&quot;ATerm&quot;</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">objects</span> <span class="op">=</span> <span class="bu">map</span> compile sources<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inherit</span> sharedLib<span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This has the advantage over traditional build systems like Make that
if a dependency isn’t specified, the build will fail. And if the build
succeeds, the build will succeed. So it’s not possible to make
incomplete dependency specifications, which could lead to inconsistent
builds.</p>
<p>A downside, however, is that Nix doesn’t support dynamic
dependencies. We need to know the derivation inputs in advance of
invoking the build script. This is why in Hillingar we need to use IFD
to import from a derivation invoking Opam to solve dependency
versions.</p>
<p>I would be very interested if anyone reading this knows if this idea
went anywhere! The only issue I see with this is the computational and
storage overhead associated with storing derivations in the Nix store
that are manageable for coarse-grained dependencies might prove too
costly for fine-grained file dependencies.</p>
<p>While on the topic of build systems, to enable more minimal builds
tighter integration with the compiler would enable analysing function
dependencies<a href="#fn39" class="footnote-ref" id="fnref39"
role="doc-noteref"><sup>39</sup></a>. For example, Dune could recompile
only certain functions that have changed since the last invocation.
Taking granularity to such a fine degree will cause a great increase in
the size of the build graph, however. Recomputing this graph for every
invocation may prove more mostly than doing the actual rebuilding after
a certain point. Perhaps persisting the build graph and calculating
differentials of it could mitigate this. A meta-build-graph, if you
will.</p>
<h2 id="conclusion"><a href="#conclusion" class="anchor"
aria-hidden="true">Conclusion</a></h2>
<p>To summarise, this project was motivated (<a
href="#introduction">§</a>) by deploying unikernels on NixOS (<a
href="#deploying-unikernels">§</a>). Towards this end, we added support
for building Mirage unikernels with Nix; we extended
<code>opam-nix</code> to support the <code>opam-monorepo</code> workflow
and created the Hillingar project to provide a usable Nix interface (<a
href="#building-unikernels">§</a>). This required scrutinizing the OCaml
and Nix ecosystems along the way in order to marry them, and some
thoughts on dependency management were developed in this context (<a
href="#dependency-management">§</a>). Many strange issues and edge cases
were uncovered during this project, but now that we’ve encoded them in
Nix hopefully others won’t have to repeat the experience!</p>
<p>While only one was the primary motivation, other benefits of building
unikernels with Nix have been revealed along the way:</p>
<ul>
<li>Reproducible and low-config Unikernel deployment using NixOS modules
is enabled.</li>
<li>Nix allows reproducible builds pinning system dependencies and
composing multiple language environments. For example, the OCaml package
<code>conf-gmp</code> is a ‘virtual package’ that relies on a system
installation of the C/Assembly library <code>gmp</code> (The GNU
Multiple Precision Arithmetic Library). Nix easily allows us to depend
on this package in a reproducible way.</li>
<li>We can use Nix to support building on different systems (<a
href="#cross-compilation">§</a>).</li>
</ul>
<p>There exists related work in the deployment and reproducible building
of Mirage unikernels. Albotross<a href="#fn40" class="footnote-ref"
id="fnref40" role="doc-noteref"><sup>40</sup></a> is one such tool for
deploying unikernels. Albotross differs from Hillingar in that it also
aims to provision resources for unikernels, share resources for
unikernels between users, and monitor unikernels, with a Unix daemon;
whereas Hillingar focuses on declaratively managing unikernel
deployments reproducibly. It would be interesting to use Albotross to
manage some of the inheritance imperative processes being unikernels as
well as share access to resources for unikernels for other users on a
NixOS system. There is also work in improving the reproducibility of
Opam packages (as Mirage unikernels are Opam packages themselves)<a
href="#fn41" class="footnote-ref" id="fnref41"
role="doc-noteref"><sup>41</sup></a>. Hillingar differs in that it only
uses Opam for version resolution, instead using Nix to provide
dependencies, which provides reproducibility with pinned Nix derivation
inputs and builds in isolation by default.</p>
<p>There are still a lot of things to improve with this project, as
detailed at <a
href="https://github.com/RyanGibb/hillingar/issues">github.com/RyanGibb/hillingar/issues</a>.
But the primary limitations of the project are that complex integration
is required with the OCaml ecosystem to solve dependency version
constraints with <code>opam-nix</code> and cross-compilation requires
cloning all sources locally with <code>opam-monorepo</code> (<a
href="#dependency-management">§</a>). Another issue that proved an
annoyance during this project is the Nix DSL’s dynamic typing. When
writing simple derivations this often isn’t a problem, but when writing
complicated logic it quickly gets in the way of productivity; the
runtime errors produced can be very hard to parse. Thankfully there is
work towards creating a typed language for the Nix deployment system,
such as Nickel<a href="#fn42" class="footnote-ref" id="fnref42"
role="doc-noteref"><sup>42</sup></a>. However gradual typing is hard,
and Nickel still isn’t ready for real-world use despite being
open-sourced (in a week as of writing this) for 2 years. Finally,
despite it being the primary motivation we haven’t actually written
NixOS module for deploying a DNS server as a unikernel. There are still
questions about how to provision resources like network access and
provide zonefile data decleratively before we do this.</p>
<p>To conclude, while NixOS and MirageOS take fundamentally very
different approaches, they’re both trying to bring some kind of
functional programming paradigm to operating systems. NixOS does this in
a top-down manner, trying to tame Unix with functional principles like
laziness and immutability<a href="#fn43" class="footnote-ref"
id="fnref43" role="doc-noteref"><sup>43</sup></a>. Whereas MirageOS does
this by throwing Unix out the window and rebuilding the world from
scratch in a very much bottom-up approach. Despite these two projects
having such different motivations and goals, Hillingar aims to get the
best from both worlds by marrying the two.</p>
<p>Finally, I want to thank some people for their help with this
project:</p>
<ul>
<li>Lucas Pluvinage for invaluable help with the OCaml ecosystem.</li>
<li>Alexander Bantyev for getting me up to speed with the
<code>opam-nix</code> project and working with me on the
<code>opam-monorepo</code> workflow integration.</li>
<li>David Allsopp for his Opam expertise.</li>
<li>Sonja Heinze for her <code>ppx</code> insights.</li>
<li>Anil Madhavapeddy for having a discussion that led to the idea for
this project.</li>
<li>Björg Bjarnadóttir for icelandic language consultation
(‘Hillingar’).</li>
<li>And finally, everyone at Tarides for being so welcoming and helpful!
<!-- A copy of this blog post can be found on Tarides website. --></li>
</ul>
<p>This work was completed with the support of <a
href="https://tarides.com/">Tarides</a>.</p>
<hr />
<p>If you spot any errors, have any questions, notice something I’ve
mentioned that someone has already thought of, or notice any incorrect
assumptions or assertions made, please get in touch at <a
href="mailto:ryan@gibbr.org">ryan@gibbr.org</a>.</p>
<p>If you have a unikernel, consider trying to build it with Hillingar,
and please report any problems at <a
href="https://github.com/RyanGibb/hillingar/issues">github.com/RyanGibb/hillingar/issues</a>!</p>
<hr />
<h4 id="references"><a href="#references" class="anchor"
aria-hidden="true">References</a></h4>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-lehnNovayaZemlyaEffect1979" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">W.
H. Lehn, <span>“The <span>Novaya Zemlya</span> effect: <span>An</span>
arctic mirage,”</span> <em>J. Opt. Soc. Am.</em>, vol. 69, no. 5, p.
776, May 1979, doi: <a
href="https://doi.org/10.1364/JOSA.69.000776">10.1364/JOSA.69.000776</a>.
[Online]. Available: <a
href="https://home.cc.umanitoba.ca/~lehn/_Papers_for_Download/NZ79.pdf">https://home.cc.umanitoba.ca/~lehn/_Papers_for_Download/NZ79.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-gibbSpatialNameSystem2022" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R.
T. Gibb, <span>“Spatial <span>Name System</span>.”</span>
<span>University of Cambridge</span>, Oct. 10, 2022 [Online]. Available:
<a
href="https://gibbr.org/resources/mphil-diss.pdf#sec-internet-arch">https://gibbr.org/resources/mphil-diss.pdf#sec-internet-arch</a>.
[Accessed: Oct. 15, 2022]</div>
</div>
<div id="ref-madhavapeddyMelangeCreatingFunctional2007"
class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">A.
Madhavapeddy, A. Ho, T. Deegan, D. Scott, and R. Sohan, <span>“Melange:
Creating a "functional" internet,”</span> <em>SIGOPS Oper. Syst.
Rev.</em>, vol. 41, no. 3, pp. 101–114, Mar. 2007, doi: <a
href="https://doi.org/10.1145/1272998.1273009">10.1145/1272998.1273009</a>.
[Online]. Available: <a
href="https://anil.recoil.org/papers/2007-eurosys-melange.pdf">https://anil.recoil.org/papers/2007-eurosys-melange.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-madhavapeddyUnikernelsLibraryOperating2013"
class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">A.
Madhavapeddy <em>et al.</em>, <span>“Unikernels: Library operating
systems for the cloud,”</span> <em>SIGARCH Comput. Archit. News</em>,
vol. 41, no. 1, pp. 461–472, Mar. 2013, doi: <a
href="https://doi.org/10.1145/2490301.2451167">10.1145/2490301.2451167</a>.
[Online]. Available: <a
href="https://anil.recoil.org/papers/2013-asplos-mirage.pdf">https://anil.recoil.org/papers/2013-asplos-mirage.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-dolstraNixSafePolicyFree2004" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">E.
Dolstra, M. de Jonge, and E. Visser, <span>“Nix: <span>A Safe</span> and
<span>Policy-Free System</span> for <span>Software
Deployment</span>,”</span> in <em>Proceedings of the 18th
<span>USENIX</span> conference on <span>System</span>
administration</em>, Nov. 2004, pp. 79–92 [Online]. Available: <a
href="https://edolstra.github.io/pubs/nspfssd-lisa2004-final.pdf">https://edolstra.github.io/pubs/nspfssd-lisa2004-final.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-dolstraNixOSPurelyFunctional2008" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">E.
Dolstra and A. Löh, <span>“<span>NixOS</span>: A purely functional
<span>Linux</span> distribution,”</span> <em>SIGPLAN Not.</em>, vol. 43,
no. 9, pp. 367–378, Sep. 2008, doi: <a
href="https://doi.org/10.1145/1411203.1411255">10.1145/1411203.1411255</a>.
[Online]. Available: <a
href="https://doi.org/10.1145/1411203.1411255">https://doi.org/10.1145/1411203.1411255</a>.
[Accessed: Oct. 13, 2022]</div>
</div>
<div id="ref-englerExokernelOperatingSystem" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">D.
R. Engler, M. F. Kaashoek, J. O’Toole, and M. I. T. Laboratory,
<span>“Exokernel: <span>An Operating System Architecture</span> for
<span>Application-Level Resource Management</span>,”</span> p. 16.
</div>
</div>
<div id="ref-coxVersionSAT2016" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">R.
Cox, <span>“Version <span>SAT</span>,”</span> Dec. 13, 2016. [Online].
Available: <a
href="https://research.swtch.com/version-sat">https://research.swtch.com/version-sat</a>.
[Accessed: Oct. 16, 2022]</div>
</div>
<div id="ref-mokhovBuildSystemsCarte2018" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">A.
Mokhov, N. Mitchell, and S. Peyton Jones, <span>“Build systems à la
carte,”</span> <em>Proc. ACM Program. Lang.</em>, vol. 2, pp. 1–29, Jul.
2018, doi: <a
href="https://doi.org/10.1145/3236774">10.1145/3236774</a>. [Online].
Available: <a
href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-dolstraPurelyFunctionalSoftware2006" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">E.
Dolstra, <span>“The purely functional software deployment model,”</span>
<span>[s.n.]</span>, <span>S.l.</span>, 2006 [Online]. Available: <a
href="https://edolstra.github.io/pubs/phd-thesis.pdf">https://edolstra.github.io/pubs/phd-thesis.pdf</a></div>
</div>
</div>
<div id="footnotes">

</div>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Generated with <a
href="https://stability.ai/blog/stable-diffusion-public-release">Stable
Diffusion</a> and <a href="https://www.gimp.org/">GIMP</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a
href="https://www.isc.org/bind/">ISC bind</a> has many <a
href="https://www.cvedetails.com/product/144/ISC-Bind.html?vendor_id=64">CVE’s</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>As ‘nix’ means snow in Latin. Credits
to Tim Cuthbertson.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>NB: we will use component,
dependency, and package somewhat interchangeably in this blog post as
they all fundamentally mean the same thing - a piece of software.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p> <a
href="https://github.com/nixos/nixpkgs">github.com/nixos/nixpkgs</a> <a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2022-09-13-nixpkgs-graph/">www.tweag.io/blog/2022-09-13-nixpkgs-graph/</a><a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a
href="https://nixos.org">nixos.org</a><a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a
href="https://nixos.org/manual/nixos/stable/index.html#sec-writing-modules">NixOS
manual Chapter 66. Writing NixOS Modules</a>.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> <a
href="https://github.com/RyanGibb/nixos">github.com/RyanGibb/nixos</a>
<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p><a
href="https://nixos.org/manual/nix/stable/package-management/channels.html">nixos.org/manual/nix/stable/package-management/channels.html</a><a
href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2020-05-25-flakes/">tweag.io/blog/2020-05-25-flakes</a><a
href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Credits to Takayuki Imada<a
href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>The full module can be found <a
href="https://github.com/NixOS/nixpkgs/blob/fe76645aaf2fac3baaa2813fd0089930689c53b5/nixos/modules/services/networking/bind.nix">here</a><a
href="#fnref13" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p><a
href="https://opam.ocaml.org/">opam.ocaml.org</a><a href="#fnref14"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>For <a
href="https://github.com/mirage/mirage-www">mirage-www</a> targetting
<code>hvt</code>.<a href="#fnref15" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p><a
href="https://0install.net">0install.net</a><a href="#fnref16"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p><a
href="https://github.com/NixOS/nixpkgs/blob/9234f5a17e1a7820b5e91ecd4ff0de449e293383/pkgs/development/ocaml-modules/">github.com/NixOS/nixpkgs
pkgs/development/ocaml-modules</a><a href="#fnref17"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p><a
href="https://github.com/ocaml/opam-repository">github.com/ocaml/opam-repository</a><a
href="#fnref18" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Bar some exceptional packages that
have multiple major versions packaged, like Postgres.<a href="#fnref19"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>In fact Arch has the same approach,
which is why it doesn’t support partial upgrades (<a
href="#nixos">§</a>).<a href="#fnref20" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p><a
href="https://github.com/NixOS/nixpkgs/issues/9682">github.com/NixOS/nixpkgs/issues/9682</a><a
href="#fnref21" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p><a
href="https://github.com/tweag/opam-nix">github.com/tweag/opam-nix</a><a
href="#fnref22" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>Another project, <a
href="https://github.com/timbertson/opam2nix">timbertson/opam2nix</a>,
also exists, but depends on a binary of itself at build time as it’s
written in OCaml as opposed to Nix, is not as minimal (higher LOC
count), and isn’t under active development (with development focused on
<a
href="https://github.com/timbertson/fetlock">github.com/timbertson/fetlock</a>)<a
href="#fnref23" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p><a
href="https://nixos.wiki/wiki/Import_From_Derivation">nixos.wiki/wiki/Import_From_Derivation</a><a
href="#fnref24" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p><a
href="https://github.com/RyanGibb/hillingar/issues/4">github.com/RyanGibb/hillingar/issues/4</a><a
href="#fnref25" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p><a
href="https://github.com/Solo5/solo5">github.com/Solo5/solo5</a><a
href="#fnref26" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn27" role="doc-endnote"><p><a
href="https://mirage.io/blog/announcing-mirage-40">mirage.io/blog/announcing-mirage-40</a><a
href="#fnref27" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p><a
href="https://dune.build">dune.build</a><a href="#fnref28"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p><a
href="https://github.com/mirage/ocaml-solo5">github.com/mirage/ocaml-solo5</a><a
href="#fnref29" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p><a
href="https://github.com/tarides/opam-monorepo">github.com/tarides/opam-monorepo</a><a
href="#fnref30" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p><a
href="https://github.com/tarides/opam-monorepo/blob/feeb325c9c8d560c6b92cbde62b6a9c5f20ed032/doc/faq.mld#L42">github.com/tarides/opam-monorepo</a><a
href="#fnref31" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn32"
role="doc-endnote"><p>https://nixos.org/manual/nixpkgs/stable/#chap-cross<a
href="#fnref32" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p><a
href="https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html">nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html</a><a
href="#fnref33" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p><a
href="https://docs.haskellstack.org/en/stable/nix_integration/">docs.haskellstack.org/en/stable/nix_integration</a><a
href="#fnref34" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p><a
href="https://github.com/nix-community/dream2nix">github.com/nix-community/dream2nix</a><a
href="#fnref35" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn36" role="doc-endnote"><p><a
href="https://github.com/timbertson/fetlock">github.com/timbertson/fetlock</a><a
href="#fnref36" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn37" role="doc-endnote"><p><a
href="https://github.com/tweag/opam-nix/blob/4e602e02a82a720c2f1d7324ea29dc9c7916a9c2/README.md#materialization">https://github.com/tweag/opam-nix#materialization</a><a
href="#fnref37" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn38" role="doc-endnote"><p><a
href="https://twitter.com/TheLortex/status/1571884882363830273">twitter.com/TheLortex/status/1571884882363830273</a><a
href="#fnref38" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn39" role="doc-endnote"><p><a
href="https://signalsandthreads.com/build-systems/#4305">signalsandthreads.com/build-systems/#4305</a><a
href="#fnref39" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn40" role="doc-endnote"><p><a
href="https://hannes.robur.coop/Posts/VMM">hannes.robur.coop/Posts/VMM</a><a
href="#fnref40" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn41" role="doc-endnote"><p><a
href="https://hannes.nqsb.io/Posts/ReproducibleOPAM">hannes.nqsb.io/Posts/ReproducibleOPAM</a><a
href="#fnref41" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn42" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2020-10-22-nickel-open-sourcing/">www.tweag.io/blog/2020-10-22-nickel-open-sourcing</a><a
href="#fnref42" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn43" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2022-07-14-taming-unix-with-nix/">tweag.io/blog/2022-07-14-taming-unix-with-nix</a><a
href="#fnref43" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
