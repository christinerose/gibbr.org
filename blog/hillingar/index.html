<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Hillingar | gibbr.org</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <link rel="shortcut icon" href="/favicon.ico">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<ul class="navbar" id="navbar">
<li>
<a href="/">home</a>
</li>
<li>
<a href="/blog/">blog</a>
</li>
<li>
<a href="/links.html">links</a>
</li>
</ul>
<h1 id="hillingar"><a href="#hillingar" class="anchor"
aria-hidden="true">Hillingar</a></h1>
<blockquote>
<p>An arctic mirage <a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
</blockquote>
<p>As part of my masters thesis I’ve been hosting an authoritative DNS
server at <code>ns1.gibbr.org</code>. And as part of my masters thesis
procrastination, I’ve been running it on a NixOS <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
machine. Deploying a DNS server using NixOS is as simple as:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>services.bind = <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">zones</span>.<span class="st">&quot;gibbr.org&quot;</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">master</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">file</span> <span class="op">=</span> <span class="st">&quot;gibbr.org.zone&quot;</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>As you might notice, however, this is running the venerable bind
written in C. Instead, using functional high-level type-safe programming
languages to create network applications can greatly benefit safety and
usability whilst maintaining performant execution <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.
One such language is OCaml.</p>
<p>The MirageOS project is a deployment method for these OCaml programs
<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>. Instead of running them as a
traditional Unix process, we instead create a specialised ‘unikernel’
operating system to run the application which allows dead code
elimination improving security with smaller attack surfaces, and
improved efficiency.</p>
<p>However, to deploy a Mirage unikernel on NixOS one has to use the
imperative deployment methodologies native to the OCaml ecosystem with
tools such as <code>opam</code> and <code>dune</code>, eliminating the
benefit of reproducible systems that Nix gives us. This blog post will
explore how we enabled reproducible deployments of Mirage unikernels
with Nix.</p>
<h1 id="nix"><a href="#nix" class="anchor"
aria-hidden="true">Nix</a></h1>
<p>At this point the curious reader might be wondering, what on earth is
‘NixOS’. To understand NixOS, we first have to understand the deployment
system it was build on: Nix.</p>
<p><img src="./nix-snowflake.svg" data-min-width="5cm"
style="width:60.0%" /></p>
<p>Nix was created as a deployment system to</p>
<p>Nix Nix is a lazy functional language for building software. To build
software, at the most basic level we invoke a compiler to turn some code
to some other code. This could be turning C code into machine code, or
Java source code to JVM bytecode. Software often has dependencies on
external libraries, files, and other parts of your operating system;
dependencies which can be explicit or implicit. Even the compiler, being
code itself, is a dependency. Nix, by default, gives us sandboxes builds
in isolation so all dependencies - implicit or explicit - are captured,
to ensure reproducibility.</p>
<p>// Nix tech details to build a vocabulary</p>
<p>Nix</p>
<p>DSL</p>
<p>nix store</p>
<p>nixpkgs</p>
<p>NixOS</p>
<p>I guess the most caveman way of doing, that would be going to a URL
on the internet, downloading the source code or the binary. If it’s the
source code, it’s compiling that and like getting the dependencies
manually and running it through some scripts and configuring it through
some random scripts too.</p>
<p>A build can’t access things outside in the wider file system or have
network access. If all the inputs These build rules with specific inputs
are called ‘deriviations’.</p>
<p>Projects often reply on interacting with system or language package
managers to make sure all the build and runtime dependencies are
available. Projects may implicitly rely on system configuration at build
or runtime. Even using a different compiler version may likely result in
a different binary.</p>
<p>Nix tries to minimise global mutable state that without knowing it
you might reply on being set up in a certain way. The benefit you get
from Nix is that you’re forced to encode this in a reproducibile way,
but that can also be frustrating at times because it can make it harder
to get off the ground. pinning all inputs, in the absence of any
non-determinism at build time guaranteing reproducibility.</p>
<p>What is a derivation? Here</p>
<p>There’s analogies to functional program verses imperative
programming, but applied to system management and software
builds/deployment.</p>
<p>It also has some other benefits - you can upgrade software
atomically. If things go badly you can easily revert because software
isn’t actually installed on your system - symlinks are created into the
immutable (read only) <code>/nix/store</code>. With packages stored at a
path of the hash of their inputs. The</p>
<p>Nix build managers build time config management, but not runtime</p>
<p>Minimising global mutable state</p>
<h4 id="nixpkgs"><a href="#nixpkgs" class="anchor"
aria-hidden="true">Nixpkgs</a></h4>
<p>With the Nix language a huge number of derivations have been created
to package software with Nix.</p>
<p>Nixpkgs</p>
<p>big monorepo [^4]</p>
<p>[^4]; <a
href="https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741">https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741</a></p>
<p>source based, but binary cache for sharing build results</p>
<h4 id="nixos"><a href="#nixos" class="anchor"
aria-hidden="true">NixOS</a></h4>
<p>On top of this is build NixOS - an OS that uses the Nix language to
manage the system configuration.</p>
<p>That’s really neat because traditionally this is just done through
like random command line things and maybe you do something and forget
how to do it and you can’t repeat it for another machine easily or even,
just like using someone else’s software.</p>
<p>If you want to deploy some software it can be as easy as changing a
line in your system configuration.</p>
<p>The reason I actually switched was because Arch kept breaking on my.
(no partial upgrades and manual rollbacks from pacman cache)</p>
<p>But the tipping point was I was upgrading my laptop and it crashed or
shut down or lost some powers or something and then the kernel was like,
it was upgrading the kernel and that’s like the most basic part of the
machine. I that crashed during that. So like the kernel was malfarmed so
I had to reinstall the kernel which is just not something you ought to
do when you have a deadline or something so that like atomic upgrades
and rollback rollback ability ability to evacuation systems.</p>
<p>GRUB stuff</p>
<p>source based - w/o binary cache it’s like gentoo</p>
<p>Instead of trying to describe Nix from scratch I’ll instead point you
in the direction of the excellent blog post ‘Nix – taming Unix with
functional programming’ by Valentin Gagarin at Tweag <a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<p>Nix wra</p>
<p>If any of the detivtion’s inputs change, the hash will change, and
the path will change. So this.captures deep traces of inputs (as each
input is also a deticaiton with a hash base on its inputs).</p>
<p>Using Nix and Nixpkgs, this approach has been extended to manage an
entire Linux operating system. Nixos System configurations</p>
<p>While Mirage was part of my masters thesis, Nix was part of my
masters thesis procrastination.</p>
<p>Nix is a declarative, functional, language for describing a system
configuration. reproducible</p>
<p>It was good supprt for derivations…</p>
<p>to install a package you write a Nix expression that descibes a
system with that pakage instaled</p>
<p>// ecosystem</p>
<p><img src="./nix-stack.svg" data-min-width="5cm"
style="width:50.0%" /></p>
<p>other things: store DSL hydra NixOps</p>
<p>package manager (command line tool)</p>
<h4 id="flakes"><a href="#flakes" class="anchor"
aria-hidden="true">Flakes</a></h4>
<p>// flakes</p>
<p>We also use Nix flakes for this project. Without going into too much
depth, for our purposes they provide a nice way to compose Nix projects.
More detail can be read at a series of blog posts by Eelco on the topic
<a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>.</p>
<h3 id="deploying-unikernels"><a href="#deploying-unikernels"
class="anchor" aria-hidden="true">Deploying unikernels</a></h3>
<p>Why couldn’t we just write a NixOS module to deploy a unikernel?
Well, first we need to support building unikernels with Nix. This blog
post will explore how to do that to provide easy deployability of Mirage
unikernels.</p>
<h3 id="mirageos"><a href="#mirageos" class="anchor"
aria-hidden="true">MirageOS</a></h3>
<p><img src="./mirage.svg" data-min-width="5cm"
style="width:50.0%" /></p>
<p>// what? What on earth is a unikernel I hear you cry?</p>
<p>A unikernel is a operating system kernel that contains low level
operating system code and high level application code bundled into one.
There is no kernel or user space - they are one and the same.</p>
<p>Puts all of the code like in one big blob and then it’s all secure
and safe. And you can remove a bunch of dead codes because there’s no
interface between the application and the open on the operating system.
There’s no interface between the application and the operating system
has been fine.</p>
<h3 id="ocaml"><a href="#ocaml" class="anchor"
aria-hidden="true">OCaml</a></h3>
<p>Mirage is written in OCaml.</p>
<p>OCaml is a functional programming language, but it a bit more
practical than others (like haskell) supporting imperative programming
too.</p>
<p>is a small perfor</p>
<p>Mirage was the first ‘unikernel’ creation framework, but it comes
from a long linage of OS OS research such as the library OS nemesis
(?)</p>
<p>// why?</p>
<p>security, performance, speed</p>
<p>it’s quite good for networking or highly networked applications as
these tend to be quite performant and security concious.</p>
<p>It was originally created to run on hypervisors in the cloud. But
there is work towards porting it to run on bare metal for IoT
applications. But hw support tricky.</p>
<h3 id="building-unikernels"><a href="#building-unikernels"
class="anchor" aria-hidden="true">Building unikernels</a></h3>
<p>NixOS modules
https://github.com/NixOS/nixpkgs/blob/fe76645aaf2fac3baaa2813fd0089930689c53b5/nixos/modules/services/networking/bind.nix</p>
<p>https://nixos.wiki/wiki/NixOS_modules</p>
<p>So Mirage is this thing. It’s written in OCaml and uses all the OCaml
tooling. In fact a lot of that tooling, like opam, was created for the
Mirage project. But this is weird-ish (opam switches - like python
venvs), and sometimes tricky to newcomers who are not familar with the
ecosystem.</p>
<p>Let’s say you just want to deploy a unikernel for all the benefits we
described but you aren’t don’t want to deal with building and deploying
it. Enter Nix: Nix is a really nice story for deploying these
unikernels. I someone’s familar with Nix, which seems to be growing in
popularitym, moreso than Mirage, it makes it really easy to deploy them
(as it’s focusd on deploying software in general).</p>
<p>But there’s no kind of support for this at the moment.</p>
<p>types of deps: - system - library - project we will be built in the
host compiler, and some will be built in the target compiler. So, a
concept that came up with was like, system dependencies, library,
dependencies and project dependencies.</p>
<p>Nix is really good system dependencies. Opam is really good at the
library dependencies. Opam kind of tries the system dependencies but not
on a very reproducible way. Nix tries the library dependencies but it
doesn’t have a way of like resolving different versions nicely. As this
huge issues shows: https://github.com/NixOS/nixpkgs/issues/9682 Nixpkgs
has one global coherent package set. In fact arch has the same approach
which is why it doesn’t support partial upgrades. This isn’t an issue
when your projects can point different dependencies in the Nix store. It
allows installing different versions of the same package because it
symlinks everything. But when you’re linking a binary this doesn’t work.
It could be interesting to link a binary using different versions of the
same package (preprending signatures with versions, say).</p>
<p>Nix doesn’t do version resolution</p>
<p>use opam to do that 0install solver NP hard problem?</p>
<p>There is an <code>opam-nix</code> project which ports opam projects
to Nix. But it doesn’t have the support for what we need. The Mirage
unikernels quite often need to be cross-compiled: compiled to run on a
machine other than the machine you’re building it on. A target they use
is solo5, which isn’t a different mircoarchitecture, but it uses a
difrert GLIBC which requires cross compilation. However, PPX is a
library that runs some code to generate other code, which doesn’t work
in a cross compilation context. The OCaml compiler does not support
cross compilation. // TODO find link But Dune, the build system does.
But opam has no concept to cross compilation. So the cross compilation
information is included in the build system instructions like
pre-processed this particular module in the host compiler, as oppsed to
the target compiler. Which is something Dune has - a tool chin which has
a target compiler embedded in it, which is modified from the host
compiler. That’s a bit tricky because it means we need to get all of the
sources for the dependencies because we don’t know in advance what
context they’re going to need to be built in? I think it could be
interesting to try and encode this in the package manager. Like this
this particular module will be will built for the host compiler or the
target compiler. But the tricky thing is some dependencies have modules
which will be built in the host compiler, and some in the target
compiler. We’re conflating the library and project deps here, because we
need the cross compilation context in the package manager, but the
package manager only has a concept of packages - and not modules -
inside a project or dependancy. You can have multiple packages inside of
development repository, and then multiple modules inside one package.
It’s kind of messy - there’s no one cohesive vision.</p>
<p>opam-monorepo: &gt; - Cross-compilation - the details of how to build
some native code can come late in the pipeline, which isn’t a problem if
the sources are available</p>
<p>Lucas has a vision of resolving dependencies by interface types
rather than numerical versions…</p>
<p>The way Mirage 4 works is - opam monorepo workflow. Gets all sources
locally for cross compilation. So what we did was add support for this
to <code>opam-nix</code> github.com/RyanGibb/hillingar And create a
project <code>hillingar</code> which wraps the Mirage tools in Nix.
github.com/RyanGibb/hillingar // TODO what does hillingar mean? As
opposed to wrapping Nix in Mirage tools. Interesting arguments both ways
- the former is better for Nix-natives and the latter better for
OCaml/Mirage natives. But this way the most sensible for me, and easiest
to prototype (no PRs). Also, it enables us to deploy unikernels using
Nix.</p>
<p>I guess my contribution was like a relatively modest PR to this open
next conversion project. But there was like so much work to go into that
like understanding what was going on and figuring out all these weird
edge cases and stuff. So let me give you the summary. I was extending
some support for an existing library to build in this workflow required
for the unikernels.</p>
<h2 id="drawbacks"><a href="#drawbacks" class="anchor"
aria-hidden="true">drawbacks:</a></h2>
<h2 id="what-are-the-benefits"><a href="#what-are-the-benefits"
class="anchor" aria-hidden="true">what are the benefits?:</a></h2>
<h3 id="conclusion"><a href="#conclusion" class="anchor"
aria-hidden="true">Conclusion</a></h3>
<p>Nix and Mirage both brining some kind of functional paradigm to OSes
but top down vs bottom up</p>
<p>Future work: - github.com/RyanGibb/hillingar - system config is nice
- NixOS module</p>
<p>relevant work: https://mirage.io/blog/deploying-mirageos-robur Nix is
source based… could deploy binaries with a binary cache as long as,
e.g. zonefile, is not part of the build</p>
<p>reproducible builds: https://hannes.nqsb.io/Posts/ReproducibleOPAM
https://robur.coop/Projects/Reproducible_builds</p>
<p>work on deploying them: https://hannes.robur.coop/Posts/VMM</p>
<p>thanks to: - Lucas for OCaml ecosystem - Balsoft for getting me to
speed with the <code>opam-nix</code> project and working with me on the
opam monorepo workflow integration - Anil for proposing the project -
bjorg for icelandic language consulting</p>
<p>This worked was completed as part of an internship with Tarides. A
copy of this blog post can be found on Tarides website.</p>
<hr />
<p>Opam2nix Depends on binary of itself at build time: not very Nixy Not
as minimal - (LOC stats) probably a function of the <code>nix</code>
DSL’s suitability in creating packages/derivations</p>
<p>After speaking to Jules I realised next is actually a language, next
packages is a package repository created using the next language, and
there is a package and the command line tool is used as a package
manager. Nix SOS is a operating system built with the same principles
Nix is teaming Unix with functional programming bracket reference tweak
blog post bracket.</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a
href="https://home.cc.umanitoba.ca/~lehn/_Papers_for_Download/NZ79.pdf">W.
H. Lehn, ‘The Novaya Zemlya effect: An arctic mirage’, J. Opt. Soc. Am.,
JOSA, vol. 69, no. 5, pp. 776–781, May 1979, doi:
10.1364/JOSA.69.000776</a>.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a
href="https://nixos.org">nixos.org</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"
role="doc-endnote"><p>https://anil.recoil.org/papers/2007-eurosys-melange.pdf<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"
role="doc-endnote"><p>https://anil.recoil.org/papers/2013-asplos-mirage.pdf<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2022-07-14-taming-unix-with-nix/">https://www.tweag.io/blog/2022-07-14-taming-unix-with-nix/</a><a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"
role="doc-endnote"><p>https://www.tweag.io/blog/2020-05-25-flakes/<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
