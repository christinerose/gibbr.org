<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Hillingar | gibbr.org</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <link rel="shortcut icon" href="/favicon.ico">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<ul class="navbar" id="navbar">
<li>
<a href="/">home</a>
</li>
<li>
<a href="/blog/">blog</a>
</li>
<li>
<a href="/links.html">links</a>
</li>
</ul>
<h1 id="hillingar-building-mirage-unikernels-with-nix"><a
href="#hillingar-building-mirage-unikernels-with-nix" class="anchor"
aria-hidden="true">Hillingar: building Mirage unikernels with
Nix</a></h1>
<p>2022-10-10</p>
<blockquote>
<p>An arctic mirage<span class="citation"
data-cites="lehnNovayaZemlyaEffect1979b"><a
href="#ref-lehnNovayaZemlyaEffect1979b"
role="doc-biblioref">[1]</a></span></p>
</blockquote>
<figure>
<img src="./hillingar2-caml.png" data-min-width="5cm"
style="width:70.0%" alt="" />
<figcaption aria-hidden="true"><a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></figcaption>
</figure>
<p>As part of my master’s thesis, I’ve been hosting an authoritative DNS
server at <code>ns1.gibbr.org</code>. More can be read in the
dissertation<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>, but DNS is one of the fundamental
building blocks of the modern Internet. And as part of my master’s
thesis procrastination, I’ve been running it on a NixOS machine. Using
NixOS, deploying a DNS server is as simple as:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">zones</span>.<span class="st">&quot;gibbr.org&quot;</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="va">master</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="va">file</span> <span class="op">=</span> <span class="st">&quot;gibbr.org.zone&quot;</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Which we can then query with</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> dig gibbr.org @ns1.gibbr.org +short</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">45.77.205.198</span></span></code></pre></div>
<p>Setting up a glue record with our registrar pointing
<code>ns1.gibbr.org</code> to the IP address of our DNS-hosting machine
allows anyone to use our authoritative server via their resolver.</p>
<p>As you might notice, however, this is running the venerable bind<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a> written in C. As an alternative,
using functional high-level type-safe programming languages to create
network applications can greatly benefit safety and usability whilst
maintaining performant execution<span class="citation"
data-cites="madhavapeddyMelangeCreatingFunctional2007"><a
href="#ref-madhavapeddyMelangeCreatingFunctional2007"
role="doc-biblioref">[2]</a></span>. One such language is OCaml.</p>
<p>The MirageOS project is a deployment method for these OCaml
programs<span class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[3]</a></span>. Instead of running them as a
traditional Unix process, we instead create a specialised ‘unikernel’
operating system to run the application, which allows dead code
elimination improving security with smaller attack surfaces and improved
efficiency.</p>
<p>However, to deploy a Mirage unikernel with NixOS one has to use the
imperative deployment methodologies native to the OCaml ecosystem,
eliminating the benefit of reproducible systems that Nix gives us. This
blog post will explore how we enabled reproducible deployments of Mirage
unikernels with Nix.</p>
<h2 id="nix"><a href="#nix" class="anchor"
aria-hidden="true">Nix</a></h2>
<figure>
<img src="./nix-snowflake.svg" data-min-width="5cm" style="width:60.0%"
alt="Nix snowflake" />
<figcaption aria-hidden="true">Nix snowflake<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></figcaption>
</figure>
<p>At this point, the curious reader might be wondering, what on earth
is ‘Nix’?</p>
<p>Nix is a deployment system that uses cryptographic hashes to compute
unique paths for components<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a> which are stored in a
read-only directory, the Nix store, at
<code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code>.
<!-- We replace references to a component with this absolute path, or symlink into the nix store for the system path, for example. -->
This provides a number of benefits including concurrent installation of
multiple versions of a package, atomic upgrades and downgrades, and
multiple user environments<span class="citation"
data-cites="dolstraNixSafePolicyFree2004"><a
href="#ref-dolstraNixSafePolicyFree2004"
role="doc-biblioref">[4]</a></span>.</p>
<p>Nix uses a declarative domain-specific language (DSL), also called
‘Nix’, to build and configure software. The snippet used to deploy the
DNS server is in fact a Nix expression. This example doesn’t demonstrate
it but Nix is Turing complete, being inspired by Haskell. Nix does not,
however, have a type system.</p>
<p>We used the DSL to write derivations for software, which describes
how to build said software with input components and a build script.
This Nix expression is then ‘instantiated’ to create ‘store derivations’
(<code>.drv</code> files), which is the low-level representation of how
to build a single component. This store derivation is ‘realised’ into a
built artefact, hereafter referred to as ‘building’.</p>
<p>Possibly the simplest Nix derivation uses bash to create a single
file containing <code>Hello, World!</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span>  <span class="op">}</span> <span class="op">}</span>:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">system</span> <span class="op">=</span> <span class="bu">builtins</span>.currentSystem<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>nixpkgs.bash<span class="sc">}</span><span class="st">/bin/bash&quot;</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&#39;&#39;echo &quot;Hello, World!&quot; &gt; $out&#39;&#39;</span> <span class="op">];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that <code>derivation</code> is a function that we’re calling
with one argument which is a set of attributes.</p>
<p>We can instantiate this Nix derivation expression to create a store
derivation:</p>
<pre><code>$ nix-instantiate default.nix
/nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv
$ nix show-derivation /nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv
{
  &quot;/nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello&quot;
      }
    },
    &quot;inputSrcs&quot;: [],
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/mnyhjzyk43raa3f44pn77aif738prd2m-bash-5.1-p16.drv&quot;: [
        &quot;out&quot;
      ]
    },
    &quot;system&quot;: &quot;x86_64-linux&quot;,
    &quot;builder&quot;: &quot;/nix/store/2r9n7fz1rxq088j6mi5s7izxdria6d5f-bash-5.1-p16/bin/bash&quot;,
    &quot;args&quot;: [ &quot;-c&quot;, &quot;echo \&quot;Hello, World!\&quot; &gt; $out&quot; ],
    &quot;env&quot;: {
      &quot;builder&quot;: &quot;/nix/store/2r9n7fz1rxq088j6mi5s7izxdria6d5f-bash-5.1-p16/bin/bash&quot;,
      &quot;name&quot;: &quot;hello&quot;,
      &quot;out&quot;: &quot;/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello&quot;,
      &quot;system&quot;: &quot;x86_64-linux&quot;
    }
  }
}</code></pre>
<p>And build the store derivation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix-store <span class="at">--realise</span> /nix/store/5d4il3h1q4cw08l6fnk4j04a19dsv71k-hello.drv</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">/nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /nix/store/4v1dx6qaamakjy5jzii6lcmfiks57mhl-hello</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Hello,</span> World!</span></code></pre></div>
<p>Most nix tooling does these two steps together:</p>
<pre><code>nix-build default.nix
this derivation will be built:
  /nix/store/q5hg3vqby8a9c8pchhjal3la9n7g1m0z-hello.drv
building &#39;/nix/store/q5hg3vqby8a9c8pchhjal3la9n7g1m0z-hello.drv&#39;...
/nix/store/zyrki2hd49am36jwcyjh3xvxvn5j5wml-hello</code></pre>
<p>Nix realisations (hereafter referred to as builds) are done in
isolation to ensure reproducibility. Projects often rely on interacting
with package managers to make sure all dependencies are available, and
may implicitly rely on system configuration at build time. To prevent
this, every Nix derivation is built in isolation, without network access
or access to the global file system, with only other Nix derivations as
inputs.</p>
<blockquote>
<p>The name Nix is derived from the Dutch word niks, meaning nothing;
build actions do not see anything that has not been explicitly declared
as an input<span class="citation"
data-cites="dolstraNixSafePolicyFree2004"><a
href="#ref-dolstraNixSafePolicyFree2004"
role="doc-biblioref">[4]</a></span>.</p>
</blockquote>
<!-- There are analogies to functional program versus imperative programming, but applied to system management and software builds/deployment. -->
<h4 id="nixpkgs"><a href="#nixpkgs" class="anchor"
aria-hidden="true">Nixpkgs</a></h4>
<p>You may have noticed a reference to <code>nixpkgs</code> in the above
derivation. As every input to a Nix derivation also has to be a Nix
derivation, one can imagine the tedium involved in creating a Nix
derivation for every dependency of your project. However, Nixpkgs<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a> is a large repository of software
packaged in Nix, where a package is a Nix derivation. We can use
packages from Nixpkgs as inputs to a Nix derivation, as we’ve done with
<code>bash</code>.</p>
<p>There is also a command line package manager installing packages from
Nixpkgs, which is why people often refer to Nix as a package manager.
While Nix, and Therefore nix package management, is primarily
source-based – since derivations describe how to build software from
source – binary deployment is an optimization of this. Since packages
are built in isolation and entirely determined by their inputs, binaries
can be transparently deployed by downloading them from a remote server
instead of building the derivation locally.</p>
<h4 id="nixos"><a href="#nixos" class="anchor"
aria-hidden="true">NixOS</a></h4>
<p>NixOS<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> is a Linux distribution built with
Nix from a modular, purely functional specification<span
class="citation" data-cites="dolstraNixOSPurelyFunctional2010"><a
href="#ref-dolstraNixOSPurelyFunctional2010"
role="doc-biblioref">[5]</a></span>. It has no traditional filesystem
hierarchy (FSH) – like <code>/bin</code>, <code>/lib</code>,
<code>/usr</code> – but instead stores all components in
<code>/nix/store</code>. The configuration of the system is managed by
Nix, with configuration files being built from modular Nix expressions.
NixOS modules are just that – small bits of configuration written in Nix
that can be composed to build a full NixOS system<a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
While many NixOS modules are provided in the Nixpkgs repository they can
also be written by a user. For example, the expression used to deploy a
DNS server is a NixOS module. The system is built from this
configuration like a Nix derivation is built.</p>
<p>NixOS minimises global mutable state that – without knowing it – you
might rely on being set up in a certain way. For example, you might
follow some instructions to run a series of shell commands and edit some
files in a certain way to get a piece of software working, but then
forgot and fail to document the process. Nix forces you to encode this
in a reproducible way, which is extremely useful for replicating
software configurations and deployments, aiming to solve the ‘It works
on my machine’ problem. Docker is often used to fix this configuration
problem, but nix aims to be more reproducible (restricting network
access). This can be frustrating at times because it can make it harder
to get off the ground with a project, but I’ve found the benefits outway
the cons for me.</p>
<p>My own NixOS configuration is publicly available<a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.
This makes it trivial to reproduce my system – a collection of various
configurations, services, and hacks – on another machine. I use it to
manage servers, workstations, and more. Compared to my previous approach
of maintaining a git repository of dotfiles, this is much more modular,
reproducible, and flexible. And if you want to deploy some new piece of
software or service, it can be as easy as changing a single line in your
system configuration.</p>
<p>Despite these advantages, the reason I switched to NixOS from Arch
Linux was simpler; NixOS allows rollbacks. As Arch packages
bleeding-edge software with rolling updates it would frequently happen
that some new version of something I was using would break due to a bug.
Arch has one global coherent package set, like Nixpkgs, except you can
use multiple instances of Nixpkgs (i.e. channels) at once as the Nix
store allows multiple versions of a dependency to be stored at once,
whereas Arch just doesn’t support partial upgrades. So the options were
to wait for the bug to be fixed, or manually rollback all the updated
packages by inspecting the pacman (the Arch package manager) log and
reinstalling the old versions from the local cache. While there may be
tools on top of pacman to improve this, the straw that broke the caml’s
back was when I was updating the Linux kernel, something went wrong, and
the machine crashed. I had to reinstall the kernel from a live USB to
fix the issue, which is not something you want to have to do to your
main workstation when you may have pressuring concerns like an upcoming
deadline. Nix’s atomic upgrades mean this wouldn’t have been an issue in
the first place. And every new system configuration creates a GRUB
entry, so you can boot previous systems from your UEFI/BIOS.</p>
<p>The blog post ‘Nix – taming Unix with functional programming’ by
Valentin Gagarin at Tweag<a href="#fn10" class="footnote-ref"
id="fnref10" role="doc-noteref"><sup>10</sup></a> gives an interesting
summary of Nix and NixOS.</p>
<p>To summarise the parts of the Nix ecosystem that we’ve discussed:</p>
<p><img src="./nix-stack.svg" data-min-width="5cm"
style="width:50.0%" /></p>
<h4 id="flakes"><a href="#flakes" class="anchor"
aria-hidden="true">Flakes</a></h4>
<p>We also use Nix flakes for this project. Without going into too much
depth, for our purposes, they enable hermetic evaluation of nix
expressions and provide a standard way to compose Nix projects.
<!-- One of the reasons for improving Nix project composing is that there's some discussion around the sustainability of the Nixpkgs monorepo workflow^[https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741](https://discourse.nixos.org/t/nixpkgss-current-development-workflow-is-not-sustainable/18741]. -->
Integrated with flakes there is also a new <code>nix</code> command
aimed at improving the UI of Nix. More detail about flakes can be read
in a series of blog posts by Eelco on the topic<a href="#fn11"
class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a>.</p>
<h2 id="mirageos"><a href="#mirageos" class="anchor"
aria-hidden="true">MirageOS</a></h2>
<figure>
<img src="./mirage-logo.svg" data-min-width="5cm" style="width:50.0%"
alt="" />
<figcaption aria-hidden="true"><a href="#fn12" class="footnote-ref"
id="fnref12" role="doc-noteref"><sup>12</sup></a></figcaption>
</figure>
<p>MirageOS is a library operating system that creates unikernels
containing low-level operating system code and high-level application
code bundled into one kernel and one address space<span class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[3]</a></span>.
<!-- security, performance, speed --> It was the first such ‘unikernel
creation framework’, but it comes from a long lineage of OS research
such as the exokernel library OS architecture<span class="citation"
data-cites="englerExokernelOperatingSystem"><a
href="#ref-englerExokernelOperatingSystem"
role="doc-biblioref">[6]</a></span>. Embedding application code in the
kernel allows for dead-code elimination – removing OS interfaces that
are used – reducing the unikernels attack surface and offering improved
efficiency.</p>
<figure>
<img src="./mirage-diagram.svg" data-min-width="5cm" style="width:70.0%"
alt="Contrasting software layers in existing VM appliances vs. unikernel’s standalone kernel compilation approach[3]" />
<figcaption aria-hidden="true">Contrasting software layers in existing
VM appliances vs. unikernel’s standalone kernel compilation
approach<span class="citation"
data-cites="madhavapeddyUnikernelsLibraryOperating2013"><a
href="#ref-madhavapeddyUnikernelsLibraryOperating2013"
role="doc-biblioref">[3]</a></span></figcaption>
</figure>
<p>Mirage unikernels are written in the typesafe high-level functional
programming language OCaml. OCaml is a bit more practical than other
functional programming languages such as Haskell for systems
programming, such as supporting falling back on impure imperative code
or mutable variables when warranted.</p>
<h2 id="deploying-mirage-unikernels"><a
href="#deploying-mirage-unikernels" class="anchor"
aria-hidden="true">Deploying Mirage unikernels</a></h2>
<p>Now that we understand what Nix and Mirage are, and we’ve motivated
the desire to deploy Mirage unikernels on a NixOS machine, what’s
stopping us from doing just that? Well, to support deploying a mirage
unikernel, such as for a DNS server, we would need to write a NixOS
module for it.</p>
<p>A paired-down<a href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a> version of the bind NixOS module
is:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">config</span><span class="op">,</span> <span class="va">lib</span><span class="op">,</span> <span class="va">pkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> lib<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">options</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> mkEnableOption <span class="st">&quot;BIND domain name server&quot;</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">zones</span> <span class="op">=</span> mkOption <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="va">config</span> <span class="op">=</span> mkIf cfg.enable <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">systemd</span>.<span class="va">services</span>.<span class="va">bind</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>      <span class="va">description</span> <span class="op">=</span> <span class="st">&quot;BIND Domain Name Server&quot;</span><span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>      <span class="va">after</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;network.target&quot;</span> <span class="op">];</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>      <span class="va">wantedBy</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;multi-user.target&quot;</span> <span class="op">];</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      <span class="va">serviceConfig</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">ExecStart</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.bind.out<span class="sc">}</span><span class="st">/sbin/named&quot;</span><span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice the reference to <code>pkgs.bind</code>. This is the Nixpkgs
repository Nix derivation for the <code>bind</code> package. Recall that
every input to a Nix derivation is itself a Nix derivation; in order to
use a package in a Nix expression – i.e. a NixOS module – we need to
build said package with Nix. Once we build a Mirage unikernel with Nix,
we can write a NixOS module to deploy it.</p>
<h2 id="building-mirage-unikernels"><a
href="#building-mirage-unikernels" class="anchor"
aria-hidden="true">Building Mirage unikernels</a></h2>
<p>Mirage uses the package manager for OCaml <code>opam</code>.
Dependencies in <code>opam</code>, as is common in programming language
package managers, has a file which specifies dependencies and their
version constraints. For example<a href="#fn14" class="footnote-ref"
id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<pre><code>depends: [
  &quot;arp&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;ethernet&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;lwt&quot; { ?monorepo }
  &quot;mirage&quot; { build &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;4.3.0&quot; }
  &quot;mirage-bootvar-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.6.0&quot; &amp; &lt; &quot;0.7.0&quot; }
  &quot;mirage-clock-solo5&quot; { ?monorepo &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;5.0.0&quot; }
  &quot;mirage-crypto-rng-mirage&quot; { ?monorepo &amp; &gt;= &quot;0.8.0&quot; &amp; &lt; &quot;0.11.0&quot; }
  &quot;mirage-logs&quot; { ?monorepo &amp; &gt;= &quot;1.2.0&quot; &amp; &lt; &quot;2.0.0&quot; }
  &quot;mirage-net-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.8.0&quot; &amp; &lt; &quot;0.9.0&quot; }
  &quot;mirage-random&quot; { ?monorepo &amp; &gt;= &quot;3.0.0&quot; &amp; &lt; &quot;4.0.0&quot; }
  &quot;mirage-runtime&quot; { ?monorepo &amp; &gt;= &quot;4.2.0&quot; &amp; &lt; &quot;4.3.0&quot; }
  &quot;mirage-solo5&quot; { ?monorepo &amp; &gt;= &quot;0.9.0&quot; &amp; &lt; &quot;0.10.0&quot; }
  &quot;mirage-time&quot; { ?monorepo }
  &quot;mirageio&quot; { ?monorepo }
  &quot;ocaml&quot; { build &amp; &gt;= &quot;4.08.0&quot; }
  &quot;ocaml-solo5&quot; { build &amp; &gt;= &quot;0.8.1&quot; &amp; &lt; &quot;0.9.0&quot; }
  &quot;opam-monorepo&quot; { build &amp; &gt;= &quot;0.3.2&quot; }
  &quot;tcpip&quot; { ?monorepo &amp; &gt;= &quot;7.0.0&quot; &amp; &lt; &quot;8.0.0&quot; }
  &quot;yaml&quot; { ?monorepo &amp; build }
]</code></pre>
<p>And each of these dependencies will have its own dependencies with
their own version constraints.</p>
<p>Nixpkgs has a large number of dependencies packaged<a href="#fn15"
class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>
which we could provide as build inputs to a Nix derivation. But Nixpkgs
has only a global set of package versions. The support for installing
multiple versions of a package concurrently comes from the fact that
they are stored at a unique path and can be referenced separately, or
symlinked, where required. All the packages in Nixpkgs depend on This is
the same approach that many other system package managers take, like
Arch Linux, as it’s too complicated organisationally to keep track Apart
from some select packages, like postgres, where many major versions are
packaged at once.</p>
<p>This is why</p>
<p>But this is a project for projects using <code>opam</code> to provide
dependencies.</p>
<ul>
<li>but nix doesn’t deal with more complicated dependency
versioning</li>
</ul>
<p>3 types: - ‘system’ (e.g. gmp) - ‘libraries’ (e.g. fmt) - ‘project’
(e.g. lib/something.ml)</p>
<p>Nix deals well with system dependencies, but not library dependencies
Opam deals well with library dependencies, but not system dependencies
Dune deals well with project libraries, but not the others (although
this may be changing)</p>
<p>could do version solving in nix</p>
<p>The build script in a Nix derivation, if it doesn’t invoke a compiler
directly, often invokes a build system like <code>make</code>. But Nix
can also be considered a build system too<span class="citation"
data-cites="mokhovBuildSystemsCarte2018"><a
href="#ref-mokhovBuildSystemsCarte2018"
role="doc-biblioref">[7]</a></span>. It takes a build graph and
computes.</p>
<p>If any of the detivtion’s inputs change, the hash will change, and
the path will change. So this.captures deep traces of inputs (as each
input is also a deticaiton with a hash base on its inputs).</p>
<p>Nix can also be thought as a coarse grained build system</p>
<p>and low level stuff? [1] E. Dolstra, The purely functional software
deployment model. S.l.: s.n., 2006. chapter 10</p>
<ul>
<li>due to nix not dealing with well with multiple versions, we need
opam’s solver</li>
<li>github.com/tweag/opam-nix creates nix derivations for OCaml projects
using it</li>
<li>We added opam monorepo support for tweag/opam-nix (merged
yesterday!)</li>
<li>and created a nix flake for building nix projects:
github.com/RyanGibb/hillingar</li>
</ul>
<p>NixOS modules
<!-- https://github.com/NixOS/nixpkgs/blob/fe76645aaf2fac3baaa2813fd0089930689c53b5/nixos/modules/services/networking/bind.nix --></p>
<p>https://nixos.wiki/wiki/NixOS_modules</p>
<p>So Mirage is this thing. It’s written in OCaml and uses all the OCaml
tooling. In fact a lot of that tooling, like opam, was created for the
Mirage project. But this is weird-ish (opam switches - like python
venvs), and sometimes tricky to newcomers who are not familar with the
ecosystem.</p>
<p>Let’s say you just want to deploy a unikernel for all the benefits we
described but you aren’t don’t want to deal with building and deploying
it. Enter Nix: Nix is a really nice story for deploying these
unikernels. I someone’s familar with Nix, which seems to be growing in
popularitym, moreso than Mirage, it makes it really easy to deploy them
(as it’s focusd on deploying software in general).</p>
<p>But there’s no kind of support for this at the moment.</p>
<p>types of deps: - system - library - project we will be built in the
host compiler, and some will be built in the target compiler. So, a
concept that came up with was like, system dependencies, library,
dependencies and project dependencies.</p>
<p>Nix is really good system dependencies. Opam is really good at the
library dependencies. Opam kind of tries the system dependencies but not
on a very reproducible way. Nix tries the library dependencies but it
doesn’t have a way of like resolving different versions nicely. As this
huge issues shows: https://github.com/NixOS/nixpkgs/issues/9682 Nixpkgs
has one global coherent package set. In fact arch has the same approach
which is why it doesn’t support partial upgrades. This isn’t an issue
when your projects can point different dependencies in the Nix store. It
allows installing different versions of the same package because it
symlinks everything. But when you’re linking a binary this doesn’t work.
It could be interesting to link a binary using different versions of the
same package (preprending signatures with versions, say).</p>
<p>Nix doesn’t do version resolution</p>
<p>use opam to do that 0install solver NP hard problem?</p>
<p>There is an <code>opam-nix</code> project which ports opam projects
to Nix. ( Opam2nix Depends on binary of itself at build time: not very
Nixy Not as minimal - (LOC stats) probably a function of the
<code>nix</code> DSL’s suitability in creating packages/derivations
)</p>
<p>But it doesn’t have the support for what we need. The Mirage
unikernels quite often need to be cross-compiled: compiled to run on a
machine other than the machine you’re building it on. A target they use
is solo5, which isn’t a different mircoarchitecture, but it uses a
difrert GLIBC which requires cross compilation. However, PPX is a
library that runs some code to generate other code, which doesn’t work
in a cross compilation context. The OCaml compiler does not support
cross compilation. // TODO find link But Dune, the build system does.
But opam has no concept to cross compilation. So the cross compilation
information is included in the build system instructions like
pre-processed this particular module in the host compiler, as oppsed to
the target compiler. Which is something Dune has - a tool chin which has
a target compiler embedded in it, which is modified from the host
compiler. That’s a bit tricky because it means we need to get all of the
sources for the dependencies because we don’t know in advance what
context they’re going to need to be built in? I think it could be
interesting to try and encode this in the package manager. Like this
this particular module will be will built for the host compiler or the
target compiler. But the tricky thing is some dependencies have modules
which will be built in the host compiler, and some in the target
compiler. We’re conflating the library and project deps here, because we
need the cross compilation context in the package manager, but the
package manager only has a concept of packages - and not modules -
inside a project or dependancy. You can have multiple packages inside of
development repository, and then multiple modules inside one package.
It’s kind of messy - there’s no one cohesive vision.</p>
<p>opam-monorepo: &gt; - Cross-compilation - the details of how to build
some native code can come late in the pipeline, which isn’t a problem if
the sources are available</p>
<p>Lucas has a vision of resolving dependencies by interface types
rather than numerical versions…</p>
<p>The way Mirage 4 works is - opam monorepo workflow. Gets all sources
locally for cross compilation. So what we did was add support for this
to <code>opam-nix</code> github.com/RyanGibb/hillingar And create a
project <code>hillingar</code> which wraps the Mirage tools in Nix.
github.com/RyanGibb/hillingar // TODO what does hillingar mean? As
opposed to wrapping Nix in Mirage tools. Interesting arguments both ways
- the former is better for Nix-natives and the latter better for
OCaml/Mirage natives. But this way the most sensible for me, and easiest
to prototype (no PRs). Also, it enables us to deploy unikernels using
Nix.</p>
<p>I guess my contribution was like a relatively modest PR to this open
next conversion project. But there was like so much work to go into that
like understanding what was going on and figuring out all these weird
edge cases and stuff. So let me give you the summary. I was extending
some support for an existing library to build in this workflow required
for the unikernels.</p>
<p>limitations: - dune cache use for monorepo deps - as we invoke dune
inside a nix derivation - Source deduplication takes the higher version
of the dev-repo -
https://github.com/tarides/opam-monorepo/issues/331</p>
<p>what are the benefits?: - enables unikernel deployments with nixOS
modules - reproducible builds with system dependencies (depexts in opam
parlance) - as well as allow composing multiple language environments -
we can benefit from nix cross compilation support (?)</p>
<p>Mirage was created to run on hypervisors in the cloud, but there is
ongoing work towards porting it to run on bare metal for IoT
applications. where repdroducibility also important
<!-- But hw support tricky. --></p>
<h2 id="conclusion"><a href="#conclusion" class="anchor"
aria-hidden="true">Conclusion</a></h2>
<p>Nix and Mirage both brining some kind of functional paradigm to OSes
but top down vs bottom up</p>
<p>Future work: - use opam monorepo’s solver - binary caching of opam
package derivations - incorporate into CI for reproducible builds -
nixOS module deployments!</p>
<ul>
<li>github.com/RyanGibb/hillingar</li>
<li>system config is nice
<ul>
<li>NixOS module</li>
</ul></li>
</ul>
<p>reflections: - the nix DSL’s lack of typing is a pain when writing
complicated code - github.com/tweag/nickel could prove interesting -
there are many obscure problems that arise when playing dependencies
like this - more so than other kinds programming - but hopefully if we
encode them with nix so others won’t have them! - mirage and nix are of
a similar theme - bringing functional paradigm to operating systems -
bottom up vs top down</p>
<p>relevant work: https://mirage.io/blog/deploying-mirageos-robur Nix is
source based… could deploy binaries with a binary cache as long as,
e.g. zonefile, is not part of the build</p>
<p>reproducible builds: https://hannes.nqsb.io/Posts/ReproducibleOPAM
https://robur.coop/Projects/Reproducible_builds</p>
<p>work on deploying them: https://hannes.robur.coop/Posts/VMM</p>
<p>Try it out!</p>
<p>``` With your unikernel…</p>
<p>$ nix flake new . -t github:/RyanGibb/hillingar $ sed -i ‘s/throw
“Put the unikernel name here”/“<unikernel-name>”/g’ flake.nix $ nix
build .#<target></p>
<p>Please open an issue (or message the #nix slack channel) if you
encounter any issues.</p>
<h4 id="thanks-to"><a href="#thanks-to" class="anchor"
aria-hidden="true">Thanks To</a></h4>
<ul>
<li>Lucas for OCaml ecosystem</li>
<li>Balsoft for getting me to speed with the <code>opam-nix</code>
project and working with me on the opam monorepo workflow
integration</li>
<li>Anil for proposing the project</li>
<li>bjorg for icelandic language consulting</li>
</ul>
<p>This worked was completed as part of an internship with Tarides. A
copy of this blog post can be found on Tarides website.</p>
<hr />
<p>If you spot any errors, or have any questions, please get in touch at
<a href="mailto:ryan@gibbr.org">ryan@gibbr.org</a>.</p>
<hr />
<h4 id="references"><a href="#references" class="anchor"
aria-hidden="true">References</a></h4>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-lehnNovayaZemlyaEffect1979b" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">W.
H. Lehn, <span>“The <span>Novaya Zemlya</span> effect: <span>An</span>
arctic mirage,”</span> <em>J. Opt. Soc. Am.</em>, vol. 69, no. 5, p.
776, May 1979, doi: <a
href="https://doi.org/10.1364/JOSA.69.000776">10.1364/JOSA.69.000776</a>.
[Online]. Available: <a
href="https://home.cc.umanitoba.ca/~lehn/_Papers_for_Download/NZ79.pdf">https://home.cc.umanitoba.ca/~lehn/_Papers_for_Download/NZ79.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-madhavapeddyMelangeCreatingFunctional2007"
class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A.
Madhavapeddy, A. Ho, T. Deegan, D. Scott, and R. Sohan, <span>“Melange:
Creating a "functional" internet,”</span> <em>SIGOPS Oper. Syst.
Rev.</em>, vol. 41, no. 3, pp. 101–114, Mar. 2007, doi: <a
href="https://doi.org/10.1145/1272998.1273009">10.1145/1272998.1273009</a>.
[Online]. Available: <a
href="https://anil.recoil.org/papers/2007-eurosys-melange.pdf">https://anil.recoil.org/papers/2007-eurosys-melange.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-madhavapeddyUnikernelsLibraryOperating2013"
class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">A.
Madhavapeddy <em>et al.</em>, <span>“Unikernels: Library operating
systems for the cloud,”</span> <em>SIGARCH Comput. Archit. News</em>,
vol. 41, no. 1, pp. 461–472, Mar. 2013, doi: <a
href="https://doi.org/10.1145/2490301.2451167">10.1145/2490301.2451167</a>.
[Online]. Available: <a
href="https://anil.recoil.org/papers/2013-asplos-mirage.pdf">https://anil.recoil.org/papers/2013-asplos-mirage.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-dolstraNixSafePolicyFree2004" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">E.
Dolstra, M. de Jonge, and E. Visser, <span>“Nix: <span>A Safe</span> and
<span>Policy-Free System</span> for <span>Software
Deployment</span>,”</span> in <em>Proceedings of the 18th
<span>USENIX</span> conference on <span>System</span>
administration</em>, Nov. 2004, pp. 79–92 [Online]. Available: <a
href="https://edolstra.github.io/pubs/nspfssd-lisa2004-final.pdf">https://edolstra.github.io/pubs/nspfssd-lisa2004-final.pdf</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
<div id="ref-dolstraNixOSPurelyFunctional2010" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">E.
Dolstra, <span>“<span>NixOS</span>: <span>A Purely Functional Linux
Distribution</span>,”</span> 2010. </div>
</div>
<div id="ref-englerExokernelOperatingSystem" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">D.
R. Engler, M. F. Kaashoek, J. O’Toole, and M. I. T. Laboratory,
<span>“Exokernel: <span>An Operating System Architecture</span> for
<span>Application-Level Resource Management</span>,”</span> p. 16.
</div>
</div>
<div id="ref-mokhovBuildSystemsCarte2018" class="csl-entry"
role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">A.
Mokhov, N. Mitchell, and S. Peyton Jones, <span>“Build systems à la
carte,”</span> <em>Proc. ACM Program. Lang.</em>, vol. 2, pp. 1–29, Jul.
2018, doi: <a
href="https://doi.org/10.1145/3236774">10.1145/3236774</a>. [Online].
Available: <a
href="https://dl.acm.org/doi/10.1145/3236774">https://dl.acm.org/doi/10.1145/3236774</a>.
[Accessed: Oct. 11, 2022]</div>
</div>
</div>
<div id="footnotes">

</div>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Generated with <a
href="https://stability.ai/blog/stable-diffusion-public-release">Stable
Diffusion</a> and <a href="https://www.gimp.org/">GIMP</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a
href="../../resources/mphil-diss.pdf#sec-internet-arch">‘Spatial Name
System’ section 2.2 Internet Architecture</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a
href="https://www.isc.org/bind/">ISC bind</a> has many <a
href="https://www.cvedetails.com/product/144/ISC-Bind.html?vendor_id=64">CVE’s</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>As ‘nix’ means snow in Latin. Credits
to Tim Cuthbertson.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>NB: we will use component,
dependency, and package somewhat interchangeably in this blog post as
they all fundamentally mean the same thing - a piece of software.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p> <a
href="https://github.com/nixos/nixpkgs">github.com/nixos/nixpkgs</a> <a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a
href="https://nixos.org">nixos.org</a><a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a
href="https://nixos.org/manual/nixos/stable/index.html#sec-writing-modules">NixOS
manual Chapter 66. Writing NixOS Modules</a>.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> <a
href="https://github.com/RyanGibb/nixos">github.com/RyanGibb/nixos</a>
<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2022-07-14-taming-unix-with-nix/">tweag.io/blog/2022-07-14-taming-unix-with-nix</a><a
href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p><a
href="https://www.tweag.io/blog/2020-05-25-flakes/">tweag.io/blog/2020-05-25-flakes</a><a
href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Credits to Takayuki Imada<a
href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>The full module can be found <a
href="https://github.com/NixOS/nixpkgs/blob/fe76645aaf2fac3baaa2813fd0089930689c53b5/nixos/modules/services/networking/bind.nix">here</a><a
href="#fnref13" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>For <a
href="https://github.com/mirage/mirage-www">mirage-www</a> targetting
<code>hvt</code>.<a href="#fnref14" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p><a
href="https://github.com/NixOS/nixpkgs/blob/9234f5a17e1a7820b5e91ecd4ff0de449e293383/pkgs/development/ocaml-modules/">github.com/NixOS/nixpkgs
pkgs/development/ocaml-modules</a><a href="#fnref15"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
